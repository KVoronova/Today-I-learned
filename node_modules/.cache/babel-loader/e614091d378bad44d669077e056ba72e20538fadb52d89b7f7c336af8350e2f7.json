{"ast":null,"code":"import { argsert } from './argsert.js';\nimport { assertNotStrictEqual } from './typings/common-types.js';\nimport { levenshtein as distance } from './utils/levenshtein.js';\nimport { objFilter } from './utils/obj-filter.js';\nconst specialKeys = ['$0', '--', '_'];\nexport function validation(yargs, usage, shim) {\n  const __ = shim.y18n.__;\n  const __n = shim.y18n.__n;\n  const self = {};\n  self.nonOptionCount = function nonOptionCount(argv) {\n    const demandedCommands = yargs.getDemandedCommands();\n    const positionalCount = argv._.length + (argv['--'] ? argv['--'].length : 0);\n    const _s = positionalCount - yargs.getInternalMethods().getContext().commands.length;\n    if (demandedCommands._ && (_s < demandedCommands._.min || _s > demandedCommands._.max)) {\n      if (_s < demandedCommands._.min) {\n        if (demandedCommands._.minMsg !== undefined) {\n          usage.fail(demandedCommands._.minMsg ? demandedCommands._.minMsg.replace(/\\$0/g, _s.toString()).replace(/\\$1/, demandedCommands._.min.toString()) : null);\n        } else {\n          usage.fail(__n('Not enough non-option arguments: got %s, need at least %s', 'Not enough non-option arguments: got %s, need at least %s', _s, _s.toString(), demandedCommands._.min.toString()));\n        }\n      } else if (_s > demandedCommands._.max) {\n        if (demandedCommands._.maxMsg !== undefined) {\n          usage.fail(demandedCommands._.maxMsg ? demandedCommands._.maxMsg.replace(/\\$0/g, _s.toString()).replace(/\\$1/, demandedCommands._.max.toString()) : null);\n        } else {\n          usage.fail(__n('Too many non-option arguments: got %s, maximum of %s', 'Too many non-option arguments: got %s, maximum of %s', _s, _s.toString(), demandedCommands._.max.toString()));\n        }\n      }\n    }\n  };\n  self.positionalCount = function positionalCount(required, observed) {\n    if (observed < required) {\n      usage.fail(__n('Not enough non-option arguments: got %s, need at least %s', 'Not enough non-option arguments: got %s, need at least %s', observed, observed + '', required + ''));\n    }\n  };\n  self.requiredArguments = function requiredArguments(argv, demandedOptions) {\n    let missing = null;\n    for (const key of Object.keys(demandedOptions)) {\n      if (!Object.prototype.hasOwnProperty.call(argv, key) || typeof argv[key] === 'undefined') {\n        missing = missing || {};\n        missing[key] = demandedOptions[key];\n      }\n    }\n    if (missing) {\n      const customMsgs = [];\n      for (const key of Object.keys(missing)) {\n        const msg = missing[key];\n        if (msg && customMsgs.indexOf(msg) < 0) {\n          customMsgs.push(msg);\n        }\n      }\n      const customMsg = customMsgs.length ? `\\n${customMsgs.join('\\n')}` : '';\n      usage.fail(__n('Missing required argument: %s', 'Missing required arguments: %s', Object.keys(missing).length, Object.keys(missing).join(', ') + customMsg));\n    }\n  };\n  self.unknownArguments = function unknownArguments(argv, aliases, positionalMap, isDefaultCommand, checkPositionals = true) {\n    var _a;\n    const commandKeys = yargs.getInternalMethods().getCommandInstance().getCommands();\n    const unknown = [];\n    const currentContext = yargs.getInternalMethods().getContext();\n    Object.keys(argv).forEach(key => {\n      if (!specialKeys.includes(key) && !Object.prototype.hasOwnProperty.call(positionalMap, key) && !Object.prototype.hasOwnProperty.call(yargs.getInternalMethods().getParseContext(), key) && !self.isValidAndSomeAliasIsNotNew(key, aliases)) {\n        unknown.push(key);\n      }\n    });\n    if (checkPositionals && (currentContext.commands.length > 0 || commandKeys.length > 0 || isDefaultCommand)) {\n      argv._.slice(currentContext.commands.length).forEach(key => {\n        if (!commandKeys.includes('' + key)) {\n          unknown.push('' + key);\n        }\n      });\n    }\n    if (checkPositionals) {\n      const demandedCommands = yargs.getDemandedCommands();\n      const maxNonOptDemanded = ((_a = demandedCommands._) === null || _a === void 0 ? void 0 : _a.max) || 0;\n      const expected = currentContext.commands.length + maxNonOptDemanded;\n      if (expected < argv._.length) {\n        argv._.slice(expected).forEach(key => {\n          key = String(key);\n          if (!currentContext.commands.includes(key) && !unknown.includes(key)) {\n            unknown.push(key);\n          }\n        });\n      }\n    }\n    if (unknown.length) {\n      usage.fail(__n('Unknown argument: %s', 'Unknown arguments: %s', unknown.length, unknown.map(s => s.trim() ? s : `\"${s}\"`).join(', ')));\n    }\n  };\n  self.unknownCommands = function unknownCommands(argv) {\n    const commandKeys = yargs.getInternalMethods().getCommandInstance().getCommands();\n    const unknown = [];\n    const currentContext = yargs.getInternalMethods().getContext();\n    if (currentContext.commands.length > 0 || commandKeys.length > 0) {\n      argv._.slice(currentContext.commands.length).forEach(key => {\n        if (!commandKeys.includes('' + key)) {\n          unknown.push('' + key);\n        }\n      });\n    }\n    if (unknown.length > 0) {\n      usage.fail(__n('Unknown command: %s', 'Unknown commands: %s', unknown.length, unknown.join(', ')));\n      return true;\n    } else {\n      return false;\n    }\n  };\n  self.isValidAndSomeAliasIsNotNew = function isValidAndSomeAliasIsNotNew(key, aliases) {\n    if (!Object.prototype.hasOwnProperty.call(aliases, key)) {\n      return false;\n    }\n    const newAliases = yargs.parsed.newAliases;\n    return [key, ...aliases[key]].some(a => !Object.prototype.hasOwnProperty.call(newAliases, a) || !newAliases[key]);\n  };\n  self.limitedChoices = function limitedChoices(argv) {\n    const options = yargs.getOptions();\n    const invalid = {};\n    if (!Object.keys(options.choices).length) return;\n    Object.keys(argv).forEach(key => {\n      if (specialKeys.indexOf(key) === -1 && Object.prototype.hasOwnProperty.call(options.choices, key)) {\n        [].concat(argv[key]).forEach(value => {\n          if (options.choices[key].indexOf(value) === -1 && value !== undefined) {\n            invalid[key] = (invalid[key] || []).concat(value);\n          }\n        });\n      }\n    });\n    const invalidKeys = Object.keys(invalid);\n    if (!invalidKeys.length) return;\n    let msg = __('Invalid values:');\n    invalidKeys.forEach(key => {\n      msg += `\\n  ${__('Argument: %s, Given: %s, Choices: %s', key, usage.stringifiedValues(invalid[key]), usage.stringifiedValues(options.choices[key]))}`;\n    });\n    usage.fail(msg);\n  };\n  let implied = {};\n  self.implies = function implies(key, value) {\n    argsert('<string|object> [array|number|string]', [key, value], arguments.length);\n    if (typeof key === 'object') {\n      Object.keys(key).forEach(k => {\n        self.implies(k, key[k]);\n      });\n    } else {\n      yargs.global(key);\n      if (!implied[key]) {\n        implied[key] = [];\n      }\n      if (Array.isArray(value)) {\n        value.forEach(i => self.implies(key, i));\n      } else {\n        assertNotStrictEqual(value, undefined, shim);\n        implied[key].push(value);\n      }\n    }\n  };\n  self.getImplied = function getImplied() {\n    return implied;\n  };\n  function keyExists(argv, val) {\n    const num = Number(val);\n    val = isNaN(num) ? val : num;\n    if (typeof val === 'number') {\n      val = argv._.length >= val;\n    } else if (val.match(/^--no-.+/)) {\n      val = val.match(/^--no-(.+)/)[1];\n      val = !Object.prototype.hasOwnProperty.call(argv, val);\n    } else {\n      val = Object.prototype.hasOwnProperty.call(argv, val);\n    }\n    return val;\n  }\n  self.implications = function implications(argv) {\n    const implyFail = [];\n    Object.keys(implied).forEach(key => {\n      const origKey = key;\n      (implied[key] || []).forEach(value => {\n        let key = origKey;\n        const origValue = value;\n        key = keyExists(argv, key);\n        value = keyExists(argv, value);\n        if (key && !value) {\n          implyFail.push(` ${origKey} -> ${origValue}`);\n        }\n      });\n    });\n    if (implyFail.length) {\n      let msg = `${__('Implications failed:')}\\n`;\n      implyFail.forEach(value => {\n        msg += value;\n      });\n      usage.fail(msg);\n    }\n  };\n  let conflicting = {};\n  self.conflicts = function conflicts(key, value) {\n    argsert('<string|object> [array|string]', [key, value], arguments.length);\n    if (typeof key === 'object') {\n      Object.keys(key).forEach(k => {\n        self.conflicts(k, key[k]);\n      });\n    } else {\n      yargs.global(key);\n      if (!conflicting[key]) {\n        conflicting[key] = [];\n      }\n      if (Array.isArray(value)) {\n        value.forEach(i => self.conflicts(key, i));\n      } else {\n        conflicting[key].push(value);\n      }\n    }\n  };\n  self.getConflicting = () => conflicting;\n  self.conflicting = function conflictingFn(argv) {\n    Object.keys(argv).forEach(key => {\n      if (conflicting[key]) {\n        conflicting[key].forEach(value => {\n          if (value && argv[key] !== undefined && argv[value] !== undefined) {\n            usage.fail(__('Arguments %s and %s are mutually exclusive', key, value));\n          }\n        });\n      }\n    });\n    if (yargs.getInternalMethods().getParserConfiguration()['strip-dashed']) {\n      Object.keys(conflicting).forEach(key => {\n        conflicting[key].forEach(value => {\n          if (value && argv[shim.Parser.camelCase(key)] !== undefined && argv[shim.Parser.camelCase(value)] !== undefined) {\n            usage.fail(__('Arguments %s and %s are mutually exclusive', key, value));\n          }\n        });\n      });\n    }\n  };\n  self.recommendCommands = function recommendCommands(cmd, potentialCommands) {\n    const threshold = 3;\n    potentialCommands = potentialCommands.sort((a, b) => b.length - a.length);\n    let recommended = null;\n    let bestDistance = Infinity;\n    for (let i = 0, candidate; (candidate = potentialCommands[i]) !== undefined; i++) {\n      const d = distance(cmd, candidate);\n      if (d <= threshold && d < bestDistance) {\n        bestDistance = d;\n        recommended = candidate;\n      }\n    }\n    if (recommended) usage.fail(__('Did you mean %s?', recommended));\n  };\n  self.reset = function reset(localLookup) {\n    implied = objFilter(implied, k => !localLookup[k]);\n    conflicting = objFilter(conflicting, k => !localLookup[k]);\n    return self;\n  };\n  const frozens = [];\n  self.freeze = function freeze() {\n    frozens.push({\n      implied,\n      conflicting\n    });\n  };\n  self.unfreeze = function unfreeze() {\n    const frozen = frozens.pop();\n    assertNotStrictEqual(frozen, undefined, shim);\n    ({\n      implied,\n      conflicting\n    } = frozen);\n  };\n  return self;\n}","map":{"version":3,"names":["argsert","assertNotStrictEqual","levenshtein","distance","objFilter","specialKeys","validation","yargs","usage","shim","__","y18n","__n","self","nonOptionCount","argv","demandedCommands","getDemandedCommands","positionalCount","_","length","_s","getInternalMethods","getContext","commands","min","max","minMsg","undefined","fail","replace","toString","maxMsg","required","observed","requiredArguments","demandedOptions","missing","key","Object","keys","prototype","hasOwnProperty","call","customMsgs","msg","indexOf","push","customMsg","join","unknownArguments","aliases","positionalMap","isDefaultCommand","checkPositionals","_a","commandKeys","getCommandInstance","getCommands","unknown","currentContext","forEach","includes","getParseContext","isValidAndSomeAliasIsNotNew","slice","maxNonOptDemanded","expected","String","map","s","trim","unknownCommands","newAliases","parsed","some","a","limitedChoices","options","getOptions","invalid","choices","concat","value","invalidKeys","stringifiedValues","implied","implies","arguments","k","global","Array","isArray","i","getImplied","keyExists","val","num","Number","isNaN","match","implications","implyFail","origKey","origValue","conflicting","conflicts","getConflicting","conflictingFn","getParserConfiguration","Parser","camelCase","recommendCommands","cmd","potentialCommands","threshold","sort","b","recommended","bestDistance","Infinity","candidate","d","reset","localLookup","frozens","freeze","unfreeze","frozen","pop"],"sources":["/Users/kseniavoronova/today-i-learned-react/node_modules/yargs/build/lib/validation.js"],"sourcesContent":["import { argsert } from './argsert.js';\nimport { assertNotStrictEqual, } from './typings/common-types.js';\nimport { levenshtein as distance } from './utils/levenshtein.js';\nimport { objFilter } from './utils/obj-filter.js';\nconst specialKeys = ['$0', '--', '_'];\nexport function validation(yargs, usage, shim) {\n    const __ = shim.y18n.__;\n    const __n = shim.y18n.__n;\n    const self = {};\n    self.nonOptionCount = function nonOptionCount(argv) {\n        const demandedCommands = yargs.getDemandedCommands();\n        const positionalCount = argv._.length + (argv['--'] ? argv['--'].length : 0);\n        const _s = positionalCount - yargs.getInternalMethods().getContext().commands.length;\n        if (demandedCommands._ &&\n            (_s < demandedCommands._.min || _s > demandedCommands._.max)) {\n            if (_s < demandedCommands._.min) {\n                if (demandedCommands._.minMsg !== undefined) {\n                    usage.fail(demandedCommands._.minMsg\n                        ? demandedCommands._.minMsg\n                            .replace(/\\$0/g, _s.toString())\n                            .replace(/\\$1/, demandedCommands._.min.toString())\n                        : null);\n                }\n                else {\n                    usage.fail(__n('Not enough non-option arguments: got %s, need at least %s', 'Not enough non-option arguments: got %s, need at least %s', _s, _s.toString(), demandedCommands._.min.toString()));\n                }\n            }\n            else if (_s > demandedCommands._.max) {\n                if (demandedCommands._.maxMsg !== undefined) {\n                    usage.fail(demandedCommands._.maxMsg\n                        ? demandedCommands._.maxMsg\n                            .replace(/\\$0/g, _s.toString())\n                            .replace(/\\$1/, demandedCommands._.max.toString())\n                        : null);\n                }\n                else {\n                    usage.fail(__n('Too many non-option arguments: got %s, maximum of %s', 'Too many non-option arguments: got %s, maximum of %s', _s, _s.toString(), demandedCommands._.max.toString()));\n                }\n            }\n        }\n    };\n    self.positionalCount = function positionalCount(required, observed) {\n        if (observed < required) {\n            usage.fail(__n('Not enough non-option arguments: got %s, need at least %s', 'Not enough non-option arguments: got %s, need at least %s', observed, observed + '', required + ''));\n        }\n    };\n    self.requiredArguments = function requiredArguments(argv, demandedOptions) {\n        let missing = null;\n        for (const key of Object.keys(demandedOptions)) {\n            if (!Object.prototype.hasOwnProperty.call(argv, key) ||\n                typeof argv[key] === 'undefined') {\n                missing = missing || {};\n                missing[key] = demandedOptions[key];\n            }\n        }\n        if (missing) {\n            const customMsgs = [];\n            for (const key of Object.keys(missing)) {\n                const msg = missing[key];\n                if (msg && customMsgs.indexOf(msg) < 0) {\n                    customMsgs.push(msg);\n                }\n            }\n            const customMsg = customMsgs.length ? `\\n${customMsgs.join('\\n')}` : '';\n            usage.fail(__n('Missing required argument: %s', 'Missing required arguments: %s', Object.keys(missing).length, Object.keys(missing).join(', ') + customMsg));\n        }\n    };\n    self.unknownArguments = function unknownArguments(argv, aliases, positionalMap, isDefaultCommand, checkPositionals = true) {\n        var _a;\n        const commandKeys = yargs\n            .getInternalMethods()\n            .getCommandInstance()\n            .getCommands();\n        const unknown = [];\n        const currentContext = yargs.getInternalMethods().getContext();\n        Object.keys(argv).forEach(key => {\n            if (!specialKeys.includes(key) &&\n                !Object.prototype.hasOwnProperty.call(positionalMap, key) &&\n                !Object.prototype.hasOwnProperty.call(yargs.getInternalMethods().getParseContext(), key) &&\n                !self.isValidAndSomeAliasIsNotNew(key, aliases)) {\n                unknown.push(key);\n            }\n        });\n        if (checkPositionals &&\n            (currentContext.commands.length > 0 ||\n                commandKeys.length > 0 ||\n                isDefaultCommand)) {\n            argv._.slice(currentContext.commands.length).forEach(key => {\n                if (!commandKeys.includes('' + key)) {\n                    unknown.push('' + key);\n                }\n            });\n        }\n        if (checkPositionals) {\n            const demandedCommands = yargs.getDemandedCommands();\n            const maxNonOptDemanded = ((_a = demandedCommands._) === null || _a === void 0 ? void 0 : _a.max) || 0;\n            const expected = currentContext.commands.length + maxNonOptDemanded;\n            if (expected < argv._.length) {\n                argv._.slice(expected).forEach(key => {\n                    key = String(key);\n                    if (!currentContext.commands.includes(key) &&\n                        !unknown.includes(key)) {\n                        unknown.push(key);\n                    }\n                });\n            }\n        }\n        if (unknown.length) {\n            usage.fail(__n('Unknown argument: %s', 'Unknown arguments: %s', unknown.length, unknown.map(s => (s.trim() ? s : `\"${s}\"`)).join(', ')));\n        }\n    };\n    self.unknownCommands = function unknownCommands(argv) {\n        const commandKeys = yargs\n            .getInternalMethods()\n            .getCommandInstance()\n            .getCommands();\n        const unknown = [];\n        const currentContext = yargs.getInternalMethods().getContext();\n        if (currentContext.commands.length > 0 || commandKeys.length > 0) {\n            argv._.slice(currentContext.commands.length).forEach(key => {\n                if (!commandKeys.includes('' + key)) {\n                    unknown.push('' + key);\n                }\n            });\n        }\n        if (unknown.length > 0) {\n            usage.fail(__n('Unknown command: %s', 'Unknown commands: %s', unknown.length, unknown.join(', ')));\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    self.isValidAndSomeAliasIsNotNew = function isValidAndSomeAliasIsNotNew(key, aliases) {\n        if (!Object.prototype.hasOwnProperty.call(aliases, key)) {\n            return false;\n        }\n        const newAliases = yargs.parsed.newAliases;\n        return [key, ...aliases[key]].some(a => !Object.prototype.hasOwnProperty.call(newAliases, a) || !newAliases[key]);\n    };\n    self.limitedChoices = function limitedChoices(argv) {\n        const options = yargs.getOptions();\n        const invalid = {};\n        if (!Object.keys(options.choices).length)\n            return;\n        Object.keys(argv).forEach(key => {\n            if (specialKeys.indexOf(key) === -1 &&\n                Object.prototype.hasOwnProperty.call(options.choices, key)) {\n                [].concat(argv[key]).forEach(value => {\n                    if (options.choices[key].indexOf(value) === -1 &&\n                        value !== undefined) {\n                        invalid[key] = (invalid[key] || []).concat(value);\n                    }\n                });\n            }\n        });\n        const invalidKeys = Object.keys(invalid);\n        if (!invalidKeys.length)\n            return;\n        let msg = __('Invalid values:');\n        invalidKeys.forEach(key => {\n            msg += `\\n  ${__('Argument: %s, Given: %s, Choices: %s', key, usage.stringifiedValues(invalid[key]), usage.stringifiedValues(options.choices[key]))}`;\n        });\n        usage.fail(msg);\n    };\n    let implied = {};\n    self.implies = function implies(key, value) {\n        argsert('<string|object> [array|number|string]', [key, value], arguments.length);\n        if (typeof key === 'object') {\n            Object.keys(key).forEach(k => {\n                self.implies(k, key[k]);\n            });\n        }\n        else {\n            yargs.global(key);\n            if (!implied[key]) {\n                implied[key] = [];\n            }\n            if (Array.isArray(value)) {\n                value.forEach(i => self.implies(key, i));\n            }\n            else {\n                assertNotStrictEqual(value, undefined, shim);\n                implied[key].push(value);\n            }\n        }\n    };\n    self.getImplied = function getImplied() {\n        return implied;\n    };\n    function keyExists(argv, val) {\n        const num = Number(val);\n        val = isNaN(num) ? val : num;\n        if (typeof val === 'number') {\n            val = argv._.length >= val;\n        }\n        else if (val.match(/^--no-.+/)) {\n            val = val.match(/^--no-(.+)/)[1];\n            val = !Object.prototype.hasOwnProperty.call(argv, val);\n        }\n        else {\n            val = Object.prototype.hasOwnProperty.call(argv, val);\n        }\n        return val;\n    }\n    self.implications = function implications(argv) {\n        const implyFail = [];\n        Object.keys(implied).forEach(key => {\n            const origKey = key;\n            (implied[key] || []).forEach(value => {\n                let key = origKey;\n                const origValue = value;\n                key = keyExists(argv, key);\n                value = keyExists(argv, value);\n                if (key && !value) {\n                    implyFail.push(` ${origKey} -> ${origValue}`);\n                }\n            });\n        });\n        if (implyFail.length) {\n            let msg = `${__('Implications failed:')}\\n`;\n            implyFail.forEach(value => {\n                msg += value;\n            });\n            usage.fail(msg);\n        }\n    };\n    let conflicting = {};\n    self.conflicts = function conflicts(key, value) {\n        argsert('<string|object> [array|string]', [key, value], arguments.length);\n        if (typeof key === 'object') {\n            Object.keys(key).forEach(k => {\n                self.conflicts(k, key[k]);\n            });\n        }\n        else {\n            yargs.global(key);\n            if (!conflicting[key]) {\n                conflicting[key] = [];\n            }\n            if (Array.isArray(value)) {\n                value.forEach(i => self.conflicts(key, i));\n            }\n            else {\n                conflicting[key].push(value);\n            }\n        }\n    };\n    self.getConflicting = () => conflicting;\n    self.conflicting = function conflictingFn(argv) {\n        Object.keys(argv).forEach(key => {\n            if (conflicting[key]) {\n                conflicting[key].forEach(value => {\n                    if (value && argv[key] !== undefined && argv[value] !== undefined) {\n                        usage.fail(__('Arguments %s and %s are mutually exclusive', key, value));\n                    }\n                });\n            }\n        });\n        if (yargs.getInternalMethods().getParserConfiguration()['strip-dashed']) {\n            Object.keys(conflicting).forEach(key => {\n                conflicting[key].forEach(value => {\n                    if (value &&\n                        argv[shim.Parser.camelCase(key)] !== undefined &&\n                        argv[shim.Parser.camelCase(value)] !== undefined) {\n                        usage.fail(__('Arguments %s and %s are mutually exclusive', key, value));\n                    }\n                });\n            });\n        }\n    };\n    self.recommendCommands = function recommendCommands(cmd, potentialCommands) {\n        const threshold = 3;\n        potentialCommands = potentialCommands.sort((a, b) => b.length - a.length);\n        let recommended = null;\n        let bestDistance = Infinity;\n        for (let i = 0, candidate; (candidate = potentialCommands[i]) !== undefined; i++) {\n            const d = distance(cmd, candidate);\n            if (d <= threshold && d < bestDistance) {\n                bestDistance = d;\n                recommended = candidate;\n            }\n        }\n        if (recommended)\n            usage.fail(__('Did you mean %s?', recommended));\n    };\n    self.reset = function reset(localLookup) {\n        implied = objFilter(implied, k => !localLookup[k]);\n        conflicting = objFilter(conflicting, k => !localLookup[k]);\n        return self;\n    };\n    const frozens = [];\n    self.freeze = function freeze() {\n        frozens.push({\n            implied,\n            conflicting,\n        });\n    };\n    self.unfreeze = function unfreeze() {\n        const frozen = frozens.pop();\n        assertNotStrictEqual(frozen, undefined, shim);\n        ({ implied, conflicting } = frozen);\n    };\n    return self;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}